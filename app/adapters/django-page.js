import DS from 'ember-data';
import fetch from 'fetch';
import ENV from '../config/environment';
import { isInDom } from '../lib/alien-dom';
import { canonicalize } from 'overhaul/services/script-loader';

export default DS.Adapter.extend({
  findRecord(store, type, id /*, snapshot */) {
    if (isInDom(id)) {
      return document;
    }

    // django-page requests can be root-relative since we're always serving from our own domain
    // except if the request is to the index route; in dev mode this will fail,
    // since it always returns the index page. forcing the domain gets the html
    // we want.
    let url = '/';
    if (id === '/') {
      if (ENV.betaTrials.isBetaSite) {
        url = ENV.wnycBetaURL;
      } else {
        url = ENV.wnycURL;
      }
    }
    return fetch(`${canonicalize(url)}${id === '/' ? '' : id}`, { headers: {'X-WNYC-EMBER':1}})
      .then(response => response.text());
  },
  // starting in ember-data 2.0, this defaults to true
  // http://emberjs.com/blog/2015/06/18/ember-data-1-13-released.html#toc_new-adapter-hooks-for-better-caching
  // ember-wormhole is the crux of our page render paradigm, and it relies on
  // element IDs which are generated by the model at run-time; reloading the model
  // in the background recomputes all the embeddedWnycComponent CPs, which causes
  // ember-wormhole to barf due to differences between the rendered IDs and the
  // model element's new IDs
  shouldBackgroundReloadRecord: () => false
});
